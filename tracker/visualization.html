<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracker visualization</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="importmap">
        {
          "imports": {
            "three": "../node_modules/three/build/three.module.js",
            "OrbitControls": "/./node_modules/three/examples/jsm/controls/OrbitControls.js",
            "FBXLoader": "../node_modules/three/examples/jsm/loaders/FBXLoader.js",
            "Stats": "../node_modules/three/examples/jsm/libs/stats.module.js",
            "EffectComposer": "../node_modules/three/examples/jsm/postprocessing/EffectComposer.js",
            "OutlinePass": "../node_modules//three/examples/jsm/postprocessing/OutlinePass.js",
            "RenderPass": "../node_modules/three/examples/jsm/postprocessing/RenderPass.js",
            "ShaderPass": "../node_modules/three/examples/jsm/postprocessing/ShaderPass.js",
            "FXAAShader": "../node_modules/three/examples/jsm/shaders/FXAAShader.js"
          }
        }
      </script>
    <script type="module">
        import * as THREE from 'three'
        import { FBXLoader } from 'FBXLoader'
        import { EffectComposer } from "EffectComposer";
        import { OutlinePass } from "OutlinePass";
        import { RenderPass } from "RenderPass";
        //Modules below are regarded to shader
        import { ShaderPass } from "ShaderPass";
        import { FXAAShader } from "FXAAShader";

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ alpha: true }); // Set alpha to true for a transparent background



        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 5);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);


        let cube = null;
        const textureLoader = new THREE.TextureLoader();

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        const fbxLoader = new FBXLoader();

        fbxLoader.load(
            './tracker.fbx',
            (object) => {
                object.scale.set(0.01, 0.01, 0.01);

                textureLoader.load(
                    './trackertexture.png',
                    (texture) => {
                        object.traverse((child) => {
                            if (child.isMesh) {
                                // Create a PBR material
                                const material = new THREE.MeshStandardMaterial({
                                    map: texture, 
                                    roughness: 0.5, 
                                    metalness: 0, 
                                });
                                child.material = material;
                            }
                        });
                    },
                    undefined,
                    (error) => {
                        console.error('An error occurred loading the texture:', error);
                    }
                );
                cube = object;
                scene.add(object);
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
            },
            (error) => {
                console.log(error);
            }
        );



        const composer = new EffectComposer(renderer);

        // Render Pass
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Outline Pass
        const outlinePass = new OutlinePass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            scene,
            camera
        );
        outlinePass.renderToScreen = true; 
        outlinePass.edgeStrength = 10; 
        outlinePass.edgeGlow = 0;
        outlinePass.edgeThickness = 0.5;
        outlinePass.pulsePeriod = 0; 
        outlinePass.usePatternTexture = false; 
        outlinePass.visibleEdgeColor.set("#ffffff"); 
        outlinePass.hiddenEdgeColor.set("#ffffff"); 
        composer.addPass(outlinePass);

        const animate = () => {
            requestAnimationFrame(animate);
            if (cube != null) {
                outlinePass.selectedObjects = [cube];
            }
            composer.render();
        };


        let gravityLine = null; 

        window.addEventListener('message', (event) => {
            if(cube == null) return;
            if (event.data.type === 'rotate') {
                // Create a quaternion from the components
                const quaternion = new THREE.Quaternion(
                    event.data.rotationX,
                    event.data.rotationY,
                    event.data.rotationZ,
                    event.data.rotationW
                );

                const gravity = new THREE.Vector3(event.data.gravityX, event.data.gravityY, event.data.gravityZ);

                quaternion.normalize();

                // Apply the quaternion rotation to the cube
                cube.quaternion.copy(quaternion);

                // Update the length of the gravity line
                if (gravityLine) {
                    updateGravityLineLength(gravity, cube.quaternion);
                } else {
                    createGravityLine(gravity);
                }
            }
        });

        // Function to create or update the gravity line
        function createGravityLine(gravity) {
            // Create a line geometry to represent the gravity vector
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                gravity.clone()
            ]);

            // Create a basic material for the line
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });

            // Create the line mesh
            gravityLine = new THREE.Line(lineGeometry, lineMaterial);

            // Add the line to the scene
            scene.add(gravityLine);
        }

        // Function to update the length of the gravity line
        function updateGravityLineLength(gravity, rot) {
            const endPoint = gravity.clone().applyQuaternion(rot); // End point at the gravity vector's tip (multiplied by 10 for visualization)
            const positions = gravityLine.geometry.attributes.position.array;
            positions[3] = endPoint.x;
            positions[4] = endPoint.y;
            positions[5] = endPoint.z;
            gravityLine.geometry.attributes.position.needsUpdate = true;
        }


        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });

        animate();
    </script>
</body>

</html>